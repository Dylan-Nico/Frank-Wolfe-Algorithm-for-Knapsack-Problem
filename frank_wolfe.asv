function [x, fval, f_star] = frank_wolfe(Q,q,x0,a,b,l,u,eps,variant) % invariant Sum_i(a_i*x_i)>=b

plot_tomo = false;
x = x0;
n = length(x0);
max_iter = n * 2000;
iterates = x;
gaps = [];
primal_errors = [];
Results = table([], [], [], [], [], [], 'VariableNames', {'Iter','gap','alpha','a * x','StepNorm', 'PrimalError'});


if isequal(variant, "away")
    away = true
    V = x;        % active vertices
    lambda = 1;

% check if starting point is feasible
if ~check_feasible(x, a, b, l, u)
    fprintf("Error: starting point no feasible, force it to be feasible\n");
    
    % put in the center of the box
    x = (l + u) / 2;

    % if second constraint not verified
    if a' * x < b
        % Compute difference and move
        t = (b - a' * x) / (a' * a);
        x = x + t * a;

        % 3) re-put in the box if necessary
        x = min(max(x, l), u);
    end
    
end

% Compute true minimum with oracle (for primal error)
[x_star, f_star] = Oracle(Q, q, a, b, l, u);


for k = 0:max_iter

    % gradient
    g = 2*Q*x + q;

    s = solveLP(g,a,b,l,u);

    d = s - x;
    
   
    
    gap = -g' * d;
    % save gap for the plot
    gaps(end+1) = gap;

    if isequal(variant, "away") && size(V,2) > 1
        [~, idx] = max(V' * g);
        v = V(:, idx);
        d_A = x - v;
        gap_A = -g' * d_A;
    else
        gap_A = -inf;
    end

    if ~use_away || gap_FW >= gap_A
        d = d_FW;
        gamma_max = 1;
        step_type = "FW";
        gap = gap_FW;
    else
        d = d_A;
        gamma_max = lambda(idx) / (1 - lambda(idx));
        step_type = "Away";
        gap = gap_A;
    end

    if(gap <= eps)
        fprintf('Converged (gap <= eps)\n');
        break;
    end

    % ---- Line search esatta per quadratiche usando la tomografia implicitamente ----
    % α = argmin f(x + α d)
    num = g' * d;
    denom = 2*d' * Q * d;

    if denom > 0
        alpha = min(1, max(0, -num / denom));
    else
        alpha = 1;
    end

    if plot_tomo && mod(k,10)==0
        plot_tomography(Q, q, x, d, alpha);
    end

    x = x + alpha*d;

    % evaluate f at current iteration
    f_x = x' * Q * x + q' * x;
    
    primal_error = abs(f_x - f_star) / max(1, abs(f_x));
    primal_errors(end+1) = primal_error;

    % Valori salvati
    iterNum   = k;
    gap_k     = gap;
    alpha_k   = alpha;
    aTx_k     = a' * x;
    stepnorm  = norm(alpha*d);
    pe_k      = primal_error;

    % Aggiungi alla tabella
    newRow = {iterNum, gap_k, alpha_k, aTx_k, stepnorm, pe_k};
    Results = [Results; newRow];

    % === WARNING VICINO AL BOUND ===
    tolBound = 1e-8;
    warning_bound(tolBound,x,l,u) ;

    iterates(:, end+1) = x;

end

fval = x' * Q * x + q' * x;

% ---- Plot 2D delle iterazioni se n = 2 ----
if n == 2
    FW_plot2D(Q, q, a, b, l, u, iterates);
end

% stampo la tabella
disp(Results);

% check x ammissible
check_feasible(x, a, b, l, u);

% plot gap
plot_gap(gaps, primal_errors);

disp(n)
disp(k)

end